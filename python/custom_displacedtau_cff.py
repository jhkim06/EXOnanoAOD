import FWCore.ParameterSet.Config as cms
from PhysicsTools.NanoAOD.common_cff import *
from PhysicsTools.NanoAOD.nano_eras_cff import *
from PhysicsTools.NanoAOD.genparticles_cff import *
from PhysicsTools.NanoAOD.taus_cff import *
from PhysicsTools.NanoAOD.muons_cff import *
from PhysicsTools.NanoAOD.jetsAK4_CHS_cff import *
from PhysicsTools.NanoAOD.jetsAK4_Puppi_cff import *
from PhysicsTools.NanoAOD.custom_btv_cff import *
from Configuration.Eras.Modifier_run3_common_cff import run3_common
import os

def add_displacedtauCHSTables(process, isMC):

    runOnMC=True
    if hasattr(process,"NANOEDMAODoutput") or hasattr(process,"NANOAODoutput"):
        runOnMC = False

        
    process.linkedObjectsCHS = cms.EDProducer("PATObjectCrossLinker",
                                      jets=cms.InputTag("finalJets"),
                                      muons=cms.InputTag("finalMuons"),
                                      electrons=cms.InputTag("finalElectrons"),
                                      lowPtElectrons=cms.InputTag("finalLowPtElectrons"),
                                      taus=cms.InputTag("finalTaus"),
                                      boostedTaus=cms.InputTag("finalBoostedTaus"),
                                      photons=cms.InputTag("finalPhotons"),
                                      vertices=cms.InputTag("slimmedSecondaryVertices")
                                      )
    
    del process.updatedJetsWithUserData.userFloats.leadTrackPt
    del process.updatedJetsWithUserData.userFloats.leptonPtRelv0
    del process.updatedJetsWithUserData.userFloats.leptonPtRelInvv0
    del process.updatedJetsWithUserData.userFloats.leptonDeltaR
    del process.updatedJetsWithUserData.userFloats.vtxPt
    del process.updatedJetsWithUserData.userFloats.vtxMass
    del process.updatedJetsWithUserData.userFloats.vtx3dL
    del process.updatedJetsWithUserData.userFloats.vtx3deL
    del process.updatedJetsWithUserData.userFloats.ptD
    del process.updatedJetsWithUserData.userFloats.qgl
    del process.updatedJetsWithUserData.userFloats.puIdNanoDisc
    del process.updatedJetsWithUserData.userFloats.muonSubtrRawPt
    del process.updatedJetsWithUserData.userFloats.muonSubtrRawEta
    del process.updatedJetsWithUserData.userFloats.muonSubtrRawPhi

    del process.updatedJetsWithUserData.userInts.vtxNtrk
    del process.updatedJetsWithUserData.userInts.leptonPdgId
    del process.updatedJetsWithUserData.userInts.puIdNanoId

    print(process.updatedJetsWithUserData.dumpPython())

    #
    # Customize jetTable
    #
    ##process.jetTable.src = cms.InputTag("finalJets") 
    process.jetTable.src = cms.InputTag("linkedObjectsCHS","jets")
    process.jetTable.name = "JetCHS" # Change collection name from "Jet" ->" JetCHS"

    #
    # Remove these tagger branches since for CHS, we just want to store ParticleNet.
    # Remove also branches related to object linking. It is only done for AK4 Puppi.
    #
    for varName in process.jetTable.variables.parameterNames_():
        if "btagDeepFlav" in varName or "btagRobustParT" in varName or "btagUParT" in varName:
          delattr(process.jetTable.variables, varName)
        if "UParTAK4Reg" in varName:
          delattr(process.jetTable.variables, varName)
        if "svIdx" in varName or "muonIdx" in varName or "electronIdx" in varName:
          delattr(process.jetTable.variables, varName)
        if "nSVs" in varName or "nElectrons" in varName or "nMuons" in varName:
          delattr(process.jetTable.variables, varName)

    del process.jetTable.variables.muonSubtrFactor
    del process.jetTable.variables.muonSubtrDeltaEta
    del process.jetTable.variables.muonSubtrDeltaPhi
    del process.jetTable.variables.qgl
    del process.jetTable.variables.puIdDisc
    del process.jetTable.variables.puId

    del process.jetTable.externalVariables.bRegCorr
    del process.jetTable.externalVariables.bRegRes
    del process.jetTable.externalVariables.cRegCorr
    del process.jetTable.externalVariables.cRegRes

    process.jetUserDataTask = cms.Task(
        process.jercVars,
    )
    process.nanoTableTaskCommon.add(process.jetUserDataTask)




    ## displaced tau part
    
    if isMC:
        # GenParticles                                                                                                                            
        genParticleTable.variables.vertexX        = Var("vertex.X"      , float)
        genParticleTable.variables.vertexY        = Var("vertex.Y"      , float)
        genParticleTable.variables.vertexZ        = Var("vertex.Z"      , float)
        genParticleTable.variables.vertexRho      = Var("vertex.Rho"    , float)
        genParticleTable.variables.vertexR        = Var("vertex.R"      , float)


    file = "NanoProd/data/particlenet_v1_a27159734e304ea4b7f9e0042baa9e22.pb"
    if os.path.exists(file):
        file_string = file
    elif os.path.exists( os.path.basename(file) ):
        file_string = os.path.basename(file)
    else:
        #file_string = "data/particlenet_v1_a27159734e304ea4b7f9e0042baa9e22.pb"
        file_string = "/afs/cern.ch/work/p/ppalit2/public/tau_pog_reco/exonanoaod_v2/CMSSW_15_0_0_pre3/src/PhysicsTools/EXOnanoAOD/data/particlenet_v1_a27159734e304ea4b7f9e0042baa9e22.pb"

    process.options = cms.untracked.PSet(
        numberOfThreads = cms.untracked.uint32(4),  # Global thread count
        numberOfStreams = cms.untracked.uint32(4),   # Should match threads
    )
     
    process.disTauTag = cms.EDProducer(
            "DisTauTag",
        graphPath = cms.string(file_string),
        jets = cms.InputTag("linkedObjectsCHS","jets"),
        pfCandidates = cms.InputTag('packedPFCandidates'),
        save_inputs  = cms.bool(False),
        batchSize = cms.uint32(8),
        #numThreads = cms.untracked.uint32(4)
        allowUnscheduled = cms.untracked.bool(True)
    )
    
    process.jetImpactParameters = cms.EDProducer(
        "JetImpactParameters",
        jets = cms.InputTag("linkedObjectsCHS","jets"),
        pfCandidates = cms.InputTag('packedPFCandidates'),
        deltaRMax = cms.double(0.4)
    )
    
    
    
    d_disTauTagVars = {
        "disTauTag_score0":     ExtVar("disTauTag:score0"       , float, doc = "Score 0"),
        "disTauTag_score1":     ExtVar("disTauTag:score1"       , float, doc = "Score 1"),
        "dxy": ExtVar("jetImpactParameters:jetDxy", float, doc = "leadingPtPFCand_dxy which is within dR=0.4 and charged/hasTrackDetails"),
        "dz": ExtVar("jetImpactParameters:jetDz", float, doc = "leadingPtPFCand_dz which is within dR=0.4 and charged/hasTrackDetails"),
        "dxyerror": ExtVar("jetImpactParameters:jetDxyError", float, doc = "leadingPtPFCand_dxyerror which is within dR=0.4 and charged/hasTrackDetails"),
        "dzerror": ExtVar("jetImpactParameters:jetDzError", float, doc = "leadingPtPFCand_dzerror which is within dR=0.4 and charged/hasTrackDetails"),
        "charge": ExtVar("jetImpactParameters:jetCharge", float, doc = "leadingPtPFCand_charge which is within dR=0.4 and charged/hasTrackDetails"), 
    }

    print ('adding disTau edproducer')
    #if useCHSJets:
    process.jetTable.externalVariables = process.jetTable.externalVariables.clone(**d_disTauTagVars)
        ## for puppi jets, use this!
    #else:
    #    process.jetPuppiTable.externalVariables = process.jetPuppiTable.externalVariables.clone(**d_disTauTagVars)
      
    process.jetTask = cms.Task(
        process.jetCorrFactorsNano,
        process.updatedJets,
        process.linkedObjectsCHS,
        # process.jetUserDataTask,
        process.updatedJetsWithUserData,
        process.finalJets,
        process.disTauTag,
        process.jetImpactParameters
        
    )

    process.nanoTableTaskCommon.add(process.jetTask)

    process.jetTablesTask = cms.Task(
        process.jetTable
    )
    process.nanoTableTaskCommon.add(process.jetTablesTask)

    #
    # Only for MC
    #
    process.jetCHSMCTable = process.jetMCTable.clone(
        src = process.jetTable.src,
        name = process.jetTable.name
    )
    process.jetMCTask.add(process.jetCHSMCTable)

    return process


def nanoAOD_customizeAddAK4CHS(process):

    runOnMC=True
    if hasattr(process,"NANOEDMAODoutput") or hasattr(process,"NANOAODoutput"):
        runOnMC = False

        
    process.linkedObjectsCHS = cms.EDProducer("PATObjectCrossLinker",
                                      jets=cms.InputTag("finalJets"),
                                      muons=cms.InputTag("finalMuons"),
                                      electrons=cms.InputTag("finalElectrons"),
                                      lowPtElectrons=cms.InputTag("finalLowPtElectrons"),
                                      taus=cms.InputTag("finalTaus"),
                                      boostedTaus=cms.InputTag("finalBoostedTaus"),
                                      photons=cms.InputTag("finalPhotons"),
                                      vertices=cms.InputTag("slimmedSecondaryVertices")
                                      )
    
    del process.updatedJetsWithUserData.userFloats.leadTrackPt
    del process.updatedJetsWithUserData.userFloats.leptonPtRelv0
    del process.updatedJetsWithUserData.userFloats.leptonPtRelInvv0
    del process.updatedJetsWithUserData.userFloats.leptonDeltaR
    del process.updatedJetsWithUserData.userFloats.vtxPt
    del process.updatedJetsWithUserData.userFloats.vtxMass
    del process.updatedJetsWithUserData.userFloats.vtx3dL
    del process.updatedJetsWithUserData.userFloats.vtx3deL
    del process.updatedJetsWithUserData.userFloats.ptD
    del process.updatedJetsWithUserData.userFloats.qgl
    del process.updatedJetsWithUserData.userFloats.puIdNanoDisc
    del process.updatedJetsWithUserData.userFloats.muonSubtrRawPt
    del process.updatedJetsWithUserData.userFloats.muonSubtrRawEta
    del process.updatedJetsWithUserData.userFloats.muonSubtrRawPhi

    del process.updatedJetsWithUserData.userInts.vtxNtrk
    del process.updatedJetsWithUserData.userInts.leptonPdgId
    del process.updatedJetsWithUserData.userInts.puIdNanoId

    print(process.updatedJetsWithUserData.dumpPython())

    #
    # Customize jetTable
    #
    ##process.jetTable.src = cms.InputTag("finalJets") 
    process.jetTable.src = cms.InputTag("linkedObjectsCHS","jets")
    process.jetTable.name = "JetCHS" # Change collection name from "Jet" ->" JetCHS"

    #
    # Remove these tagger branches since for CHS, we just want to store ParticleNet.
    # Remove also branches related to object linking. It is only done for AK4 Puppi.
    #
    for varName in process.jetTable.variables.parameterNames_():
        if "btagDeepFlav" in varName or "btagRobustParT" in varName or "btagUParT" in varName:
          delattr(process.jetTable.variables, varName)
        if "UParTAK4Reg" in varName:
          delattr(process.jetTable.variables, varName)
        if "svIdx" in varName or "muonIdx" in varName or "electronIdx" in varName:
          delattr(process.jetTable.variables, varName)
        if "nSVs" in varName or "nElectrons" in varName or "nMuons" in varName:
          delattr(process.jetTable.variables, varName)

    del process.jetTable.variables.muonSubtrFactor
    del process.jetTable.variables.muonSubtrDeltaEta
    del process.jetTable.variables.muonSubtrDeltaPhi
    del process.jetTable.variables.qgl
    del process.jetTable.variables.puIdDisc
    del process.jetTable.variables.puId

    del process.jetTable.externalVariables.bRegCorr
    del process.jetTable.externalVariables.bRegRes
    del process.jetTable.externalVariables.cRegCorr
    del process.jetTable.externalVariables.cRegRes

    process.jetUserDataTask = cms.Task(
        process.jercVars,
    )
    process.nanoTableTaskCommon.add(process.jetUserDataTask)

    process.jetTask = cms.Task(
        process.jetCorrFactorsNano,
        process.updatedJets,
        process.linkedObjectsCHS,
        process.updatedJetsWithUserData,
        process.finalJets
    )

    process.nanoTableTaskCommon.add(process.jetTask)

    process.jetTablesTask = cms.Task(
        process.jetTable
    )
    process.nanoTableTaskCommon.add(process.jetTablesTask)

    #
    # Only for MC
    #
    process.jetCHSMCTable = process.jetMCTable.clone(
        src = process.jetTable.src,
        name = process.jetTable.name
    )
    process.jetMCTask.add(process.jetCHSMCTable)

    return process

def add_displacedtauTables(process, isMC, useCHSJets = True):

    if isMC:
        # GenParticles                                                                                                                            
        genParticleTable.variables.vertexX        = Var("vertex.X"      , float)
        genParticleTable.variables.vertexY        = Var("vertex.Y"      , float)
        genParticleTable.variables.vertexZ        = Var("vertex.Z"      , float)
        genParticleTable.variables.vertexRho      = Var("vertex.Rho"    , float)
        genParticleTable.variables.vertexR        = Var("vertex.R"      , float)


    file = "NanoProd/data/particlenet_v1_a27159734e304ea4b7f9e0042baa9e22.pb"
    if os.path.exists(file):
        file_string = file
    elif os.path.exists( os.path.basename(file) ):
        file_string = os.path.basename(file)
    else:
        #file_string = "data/particlenet_v1_a27159734e304ea4b7f9e0042baa9e22.pb"
        file_string = "/afs/cern.ch/work/p/ppalit2/public/tau_pog_reco/exonanoaod_v2/CMSSW_15_0_0_pre3/src/PhysicsTools/EXOnanoAOD/data/particlenet_v1_a27159734e304ea4b7f9e0042baa9e22.pb"

    process.options = cms.untracked.PSet(
        numberOfThreads = cms.untracked.uint32(4),  # Global thread count
        numberOfStreams = cms.untracked.uint32(4),   # Should match threads
    )
        
    process.disTauTag = cms.EDProducer(
            "DisTauTag",
        graphPath = cms.string(file_string),
        jets = process.jetTable.src,
        pfCandidates = cms.InputTag('packedPFCandidates'),
        save_inputs  = cms.bool(False),
        batchSize = cms.uint32(8),
        #numThreads = cms.untracked.uint32(4)
        allowUnscheduled = cms.untracked.bool(True)
    )
    
    process.jetImpactParameters = cms.EDProducer(
        "JetImpactParameters",
        jets = process.jetTable.src,
        pfCandidates = cms.InputTag('packedPFCandidates'),
        deltaRMax = cms.double(0.4)
    )

    
    
    d_disTauTagVars = {
        "disTauTag_score0":     ExtVar("disTauTag:score0"       , float, doc = "Score 0"),
        "disTauTag_score1":     ExtVar("disTauTag:score1"       , float, doc = "Score 1"),
        "dxy": ExtVar("jetImpactParameters:jetDxy", float, doc = "leadingPtPFCand_dxy which is within dR=0.4 and charged/hasTrackDetails"),
        "dz": ExtVar("jetImpactParameters:jetDz", float, doc = "leadingPtPFCand_dz which is within dR=0.4 and charged/hasTrackDetails"),
        "dxyerror": ExtVar("jetImpactParameters:jetDxyError", float, doc = "leadingPtPFCand_dxyerror which is within dR=0.4 and charged/hasTrackDetails"),
        "dzerror": ExtVar("jetImpactParameters:jetDzError", float, doc = "leadingPtPFCand_dzerror which is within dR=0.4 and charged/hasTrackDetails"), 
    }

    print ('adding disTau edproducer')
    if useCHSJets:
        process.jetTable.externalVariables = process.jetTable.externalVariables.clone(**d_disTauTagVars)
        ## for puppi jets, use this!
    else:
        process.jetPuppiTable.externalVariables = process.jetPuppiTable.externalVariables.clone(**d_disTauTagVars)
      
    ##//process.custom_nanoaod_task = cms.Task(  
    process.disTauTagTask = cms.Task(process.disTauTag)
    process.jetImpactParametersTask = cms.Task(process.jetImpactParameters)
    ##process.schedule.associate(process.custom_nanoaod_task)
    ##//process.schedule.associate(process.exonanoaodTask1, process.exonanoaodTask2)
    ##//process.nanoTableTaskCommon.add(process.exonanoaodTask)
    ##//process.nanoTableTaskCommon.add(process.exonanoaodTask1)
    process.nanoTableTaskCommon.add(process.disTauTagTask, process.jetImpactParametersTask)
    
    return process


    


def BTVCustomNanoAODStaus(process, useCHSJets = True):
    addPFCands(process,btvNano_switch.btvNano_addallPF_switch,btvNano_switch.btvNano_addAK4_switch,btvNano_switch.btvNano_addAK8_switch)
    
    ### for MC   
    process.load("PhysicsTools.NanoAOD.btvMC_cff")
    process.nanoSequenceMC+=ak4onlyPFCandsMCSequence

    if useCHSJets:
        process.finalJetsAK4Constituents.src = src = cms.InputTag("finalJets")
        process.customAK4ConstituentsTable.jets = cms.InputTag("finalJets")
    
    return process


def run3modifier_chs(process, useCHSJets = True):
    if useCHSJets:
        run3_common.toModify(
            process.linkedObjects, jets="finalJets" ## run 2                                                                                          
        )
        _nanoTableTaskCommonRun3 = process.nanoTableTaskCommon.copy()
        _nanoTableTaskCommonRun3.add(process.jetTask)
        _nanoTableTaskCommonRun3.add(process.jetForMETTask)
        ## remove puppi table otherwise it tries to save the jet table twice                                                                          
        process.jetPuppiForMETTask.remove(process.corrT1METJetPuppiTable)
        
        process.jetTablesTask.remove(process.bjetNN)
        process.jetTablesTask.remove(process.cjetNN)
        _nanoTableTaskCommonRun3.replace(process.jetPuppiTablesTask, process.jetTablesTask)
        
        process.jetTable.externalVariables = cms.PSet()
        run3_common.toReplaceWith(
            process.nanoTableTaskCommon, _nanoTableTaskCommonRun3
        )
        run3_common.toModify(
            process.ptRatioRelForEle, srcJet="updatedJets"
        )
        run3_common.toModify(
            process.ptRatioRelForMu, srcJet="updatedJets"
        )


    return process




outputTable = cms.EDProducer("EXOnanoAODProducerTemplate",
    inputExample = cms.InputTag("offlineBeamSpot")
)

def add_customTables_template(process):

    process.outputTable = outputTable
    process.exonanoaodTask = cms.Task(process.outputTable)
    process.nanoTableTaskCommon.add(process.exonanoaodTask)

    return process
